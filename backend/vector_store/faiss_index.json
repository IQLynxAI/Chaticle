["Welcome to django-pgcrypto-expressions!\n\npgcrypto for Django models.\n\nPrerequisites\n\ndjango-pgcrypto-expressions supports Django 1.8.2 and later on Python 2.7, 3.4, pypy, and pypy3. PostgreSQL is required.\n\nInstallation\n\ndjango-pgcrypto-expressions is available on PyPI. Install it with:\n\npip install django-pgcrypto-expressions\n\nSetup\n\nYour database must have the pgcrypto extension installed. You can install it by running CREATE EXTENSION pgcrypto;.\n\nUsage\n\nJust import and use the included field classes in your models:\n\nfrom django.db import models\nfrom pgcrypto_expressions.fields import EncryptedTextField\n\n\nclass MyModel(models.Model):\n    name = EncryptedTextField()\n\n\nYou can assign values to and read values from the name field as usual, but the values will automatically be encrypted using pgcrypto\u2019s pgp_sym_encrypt function when you save it, and decrypted using pgp_sym_decrypt when you load it from the database.\n\nField types\n\nSeveral other field classes are included: EncryptedCharField, EncryptedEmailField, EncryptedIntegerField, EncryptedDateField, and EncryptedDateTimeField. All field classes accept the same arguments as their non-encrypted versions.\n\nTo create an encrypted version of some other custom field class, inherit from both EncryptedField and the other field class:\n\nfrom pgcrypto_expressions.fields import EncryptedField\nfrom somewhere import MyField\n\nclass MyEncryptedField(EncryptedField, MyField):\n    pass\n\nEncryption Key\n\nBy default your SECRET_KEY setting is used as the encryption and decryption key. You can override this by setting a PGCRYPTO_KEY setting.\n\nAlternatively, if you are using multiple databases, you can specify a PGCRYPTO_KEY per database in your DATABASES setting. For example:\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'PGCRYPTO_KEY': 'super_secret_key',\n        ...\n    },\n    'secondary': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'PGCRYPTO_KEY': 'totally_different_secret_key',\n        ...\n    },\n}\n\n\nWarning\n\nSince encryption is performed on the database server, your encryption key is sent to the database server with each query involving an encrypted field. In order to protect your key, you should only connect to your database with a TLS-protected connection. It is possible that your key could be exposed to an attacker with access to the database server via the pg_stat_activity table or query logs.\n\nFor an encrypted-fields solution that encrypts and decrypts on the application side to avoid this problem, see django-fernet-fields.\n\nIndexing, constraints, lookups, and ordering\n\nOne advantage of encrypting and decrypting within the database is that encrypted fields may still be used in any type of lookup or database expression, and queries may be ordered by an encrypted field.\n\nHowever, indexing an encrypted field is not possible without storing the decryption key in the index expression (defeating the value of the encryption), so while lookups can be made against encrypted fields, those lookups or orderings cannot be indexed, meaning their performance will degrade with the size of the table.\n\nSimilarly, unique or check constraints can\u2019t be applied to encrypted fields.\n\nContributing\n\nSee the contributing docs.\n\nTable Of Contents\nWelcome to django-pgcrypto-expressions!\nPrerequisites\nInstallation\nSetup\nUsage\nField types\nEncryption Key\nIndexing, constraints, lookups, and ordering\nContributing\nThis Page\nShow Source\nQuick search\n \n\nEnter search terms or a module, class or function name.\n\n\u00a92015, Carl Meyer. | Powered by Sphinx 1.3.1 & Alabaster 0.7.7 | Page source"]